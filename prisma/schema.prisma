// Prisma Schema for DAWN AI Assistant
// Database: PostgreSQL on Render

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// User model - stores authenticated users from NextAuth
model User {
  id            String         @id @default(uuid())
  email         String         @unique
  name          String?
  conversations Conversation[]
  createdAt     DateTime       @default(now()) @map("created_at")
  updatedAt     DateTime       @updatedAt @map("updated_at")

  @@index([email])
  @@map("users")
}

// Conversation model - stores user chat conversations
model Conversation {
  id           String    @id @default(uuid())
  userId       String    @map("user_id")
  user         User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  title        String
  preview      String?
  pinned       Boolean   @default(false)
  messageCount Int       @default(0) @map("message_count")
  agentType    String    @default("dawn") @map("agent_type") // Agent type: 'dawn' or 'lisa'
  messages     Message[] // Relation to messages
  createdAt    DateTime  @default(now()) @map("created_at")
  updatedAt    DateTime  @updatedAt @map("updated_at")
  deletedAt    DateTime? @map("deleted_at") // Soft delete for HIPAA compliance

  @@index([userId, updatedAt(sort: Desc)])
  @@index([deletedAt])
  @@index([agentType])
  @@map("conversations")
}

// Message model - stores individual chat messages
model Message {
  id             String       @id @default(uuid())
  conversationId String       @map("conversation_id")
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  role           String // "user" or "assistant"
  content        String       @db.Text // Full message text
  createdAt      DateTime     @default(now()) @map("created_at")

  @@index([conversationId, createdAt(sort: Asc)])
  @@map("messages")
}

// Document model - stores uploaded documents for LISA
model Document {
  id               String          @id @default(uuid())
  userId           String          @map("user_id")
  conversationId   String          @map("conversation_id")
  fileName         String          @map("file_name")
  fileType         String          @map("file_type")
  fileSize         Int             @map("file_size")
  fileUrl          String          @map("file_url") @db.Text
  processingStatus String          @default("pending") @map("processing_status") // pending, processing, completed, failed
  pageCount        Int?            @map("page_count")
  chunkCount       Int?            @map("chunk_count")
  metadata         Json?
  chunks           DocumentChunk[] // Relation to chunks
  createdAt        DateTime        @default(now()) @map("created_at")
  deletedAt        DateTime?       @map("deleted_at") // Soft delete for HIPAA compliance

  @@index([userId])
  @@index([conversationId])
  @@index([deletedAt])
  @@map("documents")
}

// DocumentChunk model - stores vectorized document chunks for RAG
// Note: We use Unsupported type for pgvector's vector type since Prisma doesn't have native support yet
model DocumentChunk {
  id         String    @id @default(uuid())
  documentId String    @map("document_id")
  document   Document  @relation(fields: [documentId], references: [id], onDelete: Cascade)
  chunkIndex Int       @map("chunk_index")
  content    String    @db.Text
  pageNumber Int?      @map("page_number")
  embedding  Unsupported("vector(1536)")? // text-embedding-3-small produces 1536 dimensions (works with IVFFlat)
  metadata   Json? // stores: charCount, startChar, endChar
  createdAt  DateTime  @default(now()) @map("created_at")

  @@index([documentId])
  @@map("document_chunks")
}
